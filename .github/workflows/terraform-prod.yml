#name of the worflow
name: Terraform (prod-only)

#outline the conditions
on:
  pull_request:
    branches: [main] # PRs whose BASE is prod (e.g., dev -> prod)
  push:
    branches: [main] # merge to prod
  workflow_dispatch:
    inputs:
      action:
        description: "What to run?"
        type: choice
        default: plan
        options: [plan, apply]

permissions:
  id-token: write # give workflow ability to generate OIDC
  contents: read # give workflow ability to read the repo

# set up the environments
env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  AWS_ACCOUNT_ID: ${{ vars.AWS_ACCOUNT_ID }}
  TF_STATE_BUCKET: ${{ vars.TF_STATE_BUCKET }}
  TF_LOCK_TABLE: ${{ vars.TF_LOCK_TABLE }}
  TF_BACKEND_KEY: ${{ vars.TF_BACKEND_KEY }} # prod-only
  TF_DIR: ${{ vars.TF_DIR }}
  AWS_ROLE_TO_ASSUME: arn:aws:iam::522814733082:role/GitHubActionsTerraform

jobs:
  # defining the Job
  terraform:
    runs-on: ubuntu-latest
    concurrency:
      group: terraform-prod #Ensures only one prod job runs at a time
      cancel-in-progress: false # Don’t cancel a running job if a new one starts.

    steps:
      # here wf gets the repo to the runner so later steps can read the infra
      - name: Checkout
        uses: actions/checkout@v4

      - name: Debug OIDC claims
        shell: bash
        run: |
          set -e
          TOK_JSON=$(curl -sS -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=sts.amazonaws.com")
          IDTOK=$(echo "$TOK_JSON" | jq -r '.value')
          echo "OIDC token acquired."

          # Decode JWT payload
          PAYLOAD=$(echo "$IDTOK" | awk -F. '{print $2}' | tr '_-' '/+' | base64 -d 2>/dev/null || true)
          echo "Payload:"
          echo "$PAYLOAD" | jq .

          echo "Important claims:"
          echo "$PAYLOAD" | jq -r '.sub, .repository, .ref, .workflow, .aud'

      - name: fetch GitHub OIDC token
        shell: bash
        run: |
          set -e
          if [ -z "${ACTIONS_ID_TOKEN_REQUEST_URL}" ] || [ -z "${ACTIONS_ID_TOKEN_REQUEST_TOKEN}" ]; then
           echo "❌ Missing id-token permission. Add 'permissions: id-token: write' at top of workflow."; exit 1
           fi
          TOK_JSON=$(curl -sS -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
          "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=sts.amazonaws.com")
          IDTOK=$(echo "$TOK_JSON" | jq -r '.value')
          if [ "$IDTOK" = "null" ] || [ -z "$IDTOK" ]; then
          echo "❌ GitHub did not issue an ID token. Check 'permissions: id-token: write' and that this run is NOT from a forked PR."; exit 1
          fi
           echo "✅ OIDC token fetched."

           PAYLOAD=$(echo "$IDTOK" | awk -F. '{print $2}' | tr '_-' '/+' | base64 -d 2>/dev/null || true)
           echo "Claims:"; echo "$PAYLOAD" | jq .

      - name: call STS assume-role-with-web-identity directly
        shell: bash
        env:
          ROLE_ARN: arn:aws:iam::522814733082:role/GitHubActionsTerraform
        run: |

          # This call does NOT need prior AWS creds; it uses the OIDC token directly.
          set +e
          RESP=$(aws sts assume-role-with-web-identity \
            --role-arn "${ROLE_ARN}" \
            --role-session-name gha-oidc-test \
            --web-identity-token "$IDTOK" \
            --duration-seconds 3600 \
            --output json 2>&1)
          RC=$?
          set -e
          echo "$RESP"
          if [ $RC -ne 0 ]; then
            echo "❌ STS rejected the token. Check the message above for the exact reason (audience, principal, or condition mismatch)."; exit $RC
          fi
          echo "✅ STS returned credentials."

        # authenticates
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::522814733082:role/GitHubActionsTerraform
          aws-region: ${{ env.AWS_REGION }}

      - name: Sanity show configured AWS_* env vars
        run: env | grep ^AWS_ || true

      - name: Who am I? (STS)
        run: aws sts get-caller-identity
      - name: Show AWS identity # <-- run AFTER credentials are configured
        run: aws sts get-caller-identity
        # installs tersraform in the runner
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

        #points terraform to the remote backend
      - name: Terraform Init (prod backend)
        run: |
          terraform -chdir=$TF_DIR init \
            -backend-config="bucket=$TF_STATE_BUCKET" \
            -backend-config="region=$AWS_REGION" \
            -backend-config="dynamodb_table=$TF_LOCK_TABLE" \
            -backend-config="key=$TF_BACKEND_KEY"

      # PLAN only on PR to prod (optionally ensure head is dev)
      - name: Terraform Plan (PR dev -> prod)
        if: github.event_name == 'pull_request' && github.event.pull_request.head.ref == 'dev'
        run: terraform -chdir=$TF_DIR plan -input=false -no-color

      # APPLY only on merge/push to prod
      - name: Terraform Apply (merge to prod)
        if: github.event_name == 'push'
        run: terraform -chdir=$TF_DIR apply -auto-approve -input=false
